#include "main.h"

/*
 * Type the command './edf_hull --help ' for more usage information.
 */

/*Command given at run-time*/
char command[LENGTH_COMMAND];

/*Setting up program parser*/
const char *argp_program_version =
    "edf_hull 2.0\nReleased under MIT License.\nCopyright (c) [2023] [Enrico "
    "Bini]";

static char doc[] =
    "Obtains minimal set of constraints for EDF "
    "schedulability by convex hull point reduction"
    "for one or several task sets.\v"
    "When option '-s' is not included or when INPUT_FILE is unspecified, "
    "the program reads input data from text file \"./input_task_set.txt\".\n\v";
static char args_doc[] = "";

/*List of options supported by parser*/
struct argp_option options[] = {
    {0, 0, 0, 0, "Mode options:", 1},
    {"verbose", 'v', no_argument, 0, "Show verbose output."},
    {"input-file", 'i', "INPUT_FILE", OPTION_ARG_OPTIONAL,
     "(FILE MODE) Apply the convex hull point "
     "reduction to the task set read from file."},

    /*Following arguments are the random mode settings */
    {"random", 's', no_argument, 0,
     "(RANDOM MODE) Apply the convex hull point "
     "reduction to a task set randomly generated by seed."},
    {0, 0, 0, 0,
     "List of mandatory options to include for random generation of task sets:",
     7},
    {"rand-seed", EDFH_SEED, "SEED", 0,
     "Specify seed used in task set generation. Ignored if option "
     "\'num-repeat\' is specified."},
    {"num", EDFH_NUM_TASKS, "NUM_TASKS", 0,
     "Specify number of tasks in task set."},
    {"period-min", EDFH_PERIOD_MIN, "PERIOD_MIN", 0,
     "Specify the minimum period of a task within the task set."},
    {"period-max", EDFH_PERIOD_MAX, "PERIOD_MAX", 0,
     "Specify the maximum period of a task within the task set"},
    {"relative-dl-avg", EDFH_RELATIVE_DL_AVG, "RELATIVE_DL_AVG", 0,
     "Specify the relative deadline average."},
    {"relative-dl-var", EDFH_RELATIVE_DL_VAR, "RELATIVE_DL_VAR", 0,
     "Specify the relative deadline variance."},
    {"eps", EDFH_EPS, "EPS", 0, "Specify sensitivity of the hyperperiod."},

    {0, 0, 0, 0, "Additional options to use with RANDOM MODE:", 15},
    {"num-repeat", EDFH_N_REPEAT, "NUM_REPEAT", 0,
     "Specify number of times a task set must be randomly generated given "
     "these settings and evaluated through the convex hull point reduction."},
    {"phasing", EDFH_PHASING, no_argument, 0,
     "Randomly generate offset for each task. Phasing "
     "is by default absent."},
    {"add_constraints_info", 'e', no_argument, 0,
     "Calculate additional info on minimal constraints related to a particular "
     "task set. Option 'num-repeat' is automatically set to "
     "1. Since the task set is internally generated, all mandatory options for "
     "random mode are required."},

    {0, 0, 0, 0, "Informational Options:", -1},
    {0}};

/* Used by main to communicate with parser. */
struct arguments {
  int verbose;
  int add_constraints_info;
  enum { EDFH_FILE_MODE, EDFH_RANDOM_MODE } mode;
  char *input_data;
  ts_rand_t rand_setup;
};

/*
 * Parsing options and setting flags invoking the proper function depending of
 * the option. For any key value not recognized returns ARGP_ERR_UNKNOWN
 */
static error_t parser(int key, char *arg, struct argp_state *state) {
  struct arguments *arguments = state->input;
  switch (key) {
  case ARGP_KEY_INIT:
    arguments->input_data = "input_task_set.txt";
    arguments->verbose = false;
    arguments->add_constraints_info = false;

    /* Default mode is reading from input */
    arguments->mode = EDFH_FILE_MODE;
    arguments->rand_setup.n_repeat =
        1; /*Only one task set is randomly generated from settings*/
    arguments->rand_setup.seed = 0;
    break;
  case ARGP_KEY_END: /* Final argument validation*/

    /*Checking if user specified arguments for all the mandatory options for
     * random mode */
    if (arguments->mode == EDFH_RANDOM_MODE) {
      if (!verify_arguments_random_mode()) {
        argp_error(state, "Insufficient arguments for randomization.");
      }
      if (arguments->mode == EDFH_RANDOM_MODE &&
          arguments->add_constraints_info) {
        arguments->rand_setup.n_repeat =
            1; /*input for option 'num-repeat' is ignored */
      }
    }
    break;
  case 'v':
    arguments->verbose = true;
    break;
  case 'i':
    arguments->mode = EDFH_FILE_MODE;
    if (arg != NULL) {
      arguments->input_data = arg;
    }
    break;
  case 'e':
    arguments->add_constraints_info = true;
    arguments->mode = EDFH_RANDOM_MODE;
    break;
  case 's':
    arguments->mode = EDFH_RANDOM_MODE;
    break;
  case EDFH_SEED:
    if (verify_arg_int(arg)) {
      sscanf(arg, "%d", &arguments->rand_setup.seed);
    } else {
      argp_error(state, "invalid input for random seed");
      return ARGP_KEY_ERROR;
    }
    break;
  case EDFH_NUM_TASKS:
    if (verify_arg_int(arg)) {
      sscanf(arg, "%d", &arguments->rand_setup.num);
    } else {
      argp_error(state, "invalid input for num");
    }
    break;
  case EDFH_PERIOD_MIN:
    sscanf(arg, "%lf", &arguments->rand_setup.per_min);
    break;
  case EDFH_PERIOD_MAX:
    sscanf(arg, "%lf", &arguments->rand_setup.per_max);
    break;
  case EDFH_PHASING:
    arguments->rand_setup.phasing = 1;
    break;
  case EDFH_RELATIVE_DL_AVG:
    sscanf(arg, "%lf", &arguments->rand_setup.norm_dl_avg);
    break;
  case EDFH_RELATIVE_DL_VAR:
    sscanf(arg, "%lf", &arguments->rand_setup.norm_dl_var);
    break;
  case EDFH_EPS:
    sscanf(arg, "%lf", &arguments->rand_setup.eps);
    break;
  case EDFH_N_REPEAT:
    if (arg != NULL) {
      sscanf(arg, "%d", &arguments->rand_setup.n_repeat);
    }
    break;
  default:
    return ARGP_ERR_UNKNOWN;
  }
  return 0;
}

void get_command(int argc, char **argv) {
  int pos = 0;
  int i;

  for (i = 0; i < argc; i++) {
    if (i == 0)
      pos += sprintf(&command[pos], "%s", argv[i]);
    else
      pos += sprintf(&command[pos], " %s", argv[i]);
  }
}

/*Data type that contains all options and a pointer to a function that Argp
will call to assist in parsing */
struct argp argp = {options, parser, args_doc, doc, 0, 0, 0};

/*Contains arguments passed to command-line options*/
struct arguments arguments;

int main(int argc, char *argv[]) {
  get_command(argc, argv);

  /*Parsing command-line options*/
  if (argp_parse(&argp, argc, argv, 0, 0, &arguments) == ARGP_KEY_ERROR) {
    fprintf(stderr, "%s:%d: Error during parsing options .\n", __FILE__,
            __LINE__);
    exit(EXIT_FAILURE);
  }

  if (arguments.mode == EDFH_FILE_MODE) { /* Input file mode */
    main_file_mode(arguments.input_data);
  } else if (arguments.add_constraints_info &&
             arguments.mode != EDFH_FILE_MODE) {
    main_constraints_info();
  } else { /* Random mode */

    /*Print randomization settings*/
    print_rand_setup(arguments.rand_setup);

    if (arguments.rand_setup.n_repeat == 1) {
      main_rand_mode(); /* Executes the procedure on a single random taskset
                         */
    } else {
      iterate_random_mode(); /* Executes the procedure on multiple random
                                tasksets */
    }
  }
}

void iterate_random_mode() {
  char *filename = malloc(MAX_SIZE_STR_FILENAME);

  create_descriptive_filename(filename);

  arguments.rand_setup.fp_stats_csv = fopen(filename, "w");

  if (arguments.rand_setup.fp_stats_csv == NULL) {
    fprintf(stderr, "main: unable to open file\n");
    exit(EXIT_FAILURE);
  }

  /*Printing header of csv file*/
  fprintf(arguments.rand_setup.fp_stats_csv, "Seed,");
  for (int i = 1; i <= arguments.rand_setup.num; i++) {
    fprintf(arguments.rand_setup.fp_stats_csv, "T%d,D%d,Ratio%d,", i, i, i);
  }
  fprintf(arguments.rand_setup.fp_stats_csv,
          "H,m,Original_m,Percentage_m,Command\n");

  for (int i = 0; i < arguments.rand_setup.n_repeat; i++) {
    if (i == 1) {
      printf("[edf_hull] Printing %d row(s) on file \'./%s\'\n",
             arguments.rand_setup.n_repeat, filename);
    }
    arguments.rand_setup.seed = i + 1; /*The seed will serve as an identifier
                                          for each task in the csv file*/
    main_rand_mode();
  }

  fclose(arguments.rand_setup.fp_stats_csv);
  free(filename);
}

/**
 * Creates a filename that describes the settings used for the randomization
 */
void create_descriptive_filename(char *filename) {
  char *n_repeats;
  switch (arguments.rand_setup.n_repeat) {
  case 1000000:
    n_repeats = "1m";
    break;
  case 100000:
    n_repeats = "100k";
    break;
  case 10000:
    n_repeats = "10k";
    break;
  case 1000:
    n_repeats = "1k";
    break;
  case 100:
    n_repeats = "100";
    break;
  case 10:
    n_repeats = "10";
    break;
  case 1:
    n_repeats = "1";
    break;
  }

  sprintf(filename, "../datasets/new/%s_t%.0f-%.0f_d_avg%.1f-var%.1f.csv",
          n_repeats, arguments.rand_setup.per_min, arguments.rand_setup.per_max,
          arguments.rand_setup.norm_dl_avg, arguments.rand_setup.norm_dl_var);
}

/*
 * If task set is generated by seed, a number of parameters must be defined
 * on command line by the user. This function returns 1 if all of these
 * arguments have been specified, 0 if not and prints an error message to
 * indicate the missing argument.
 */
int verify_arguments_random_mode() {
  ts_rand_t *settings = &arguments.rand_setup;
  if (settings->seed == 0 && settings->n_repeat == 1) {
    fprintf(stderr,
            "%s:%d: No seed specified. Please specify a seed (e.g "
            "--rand-seed=110).\n",
            __FILE__, __LINE__);
    return 0;
  }
  if (settings->num == 0) {
    fprintf(stderr,
            "%s:%d: Number of tasks invalid. Please specify a non-zero "
            "positive integer (e.g. "
            "--num=3).\n",
            __FILE__, __LINE__);
    return 0;
  }
  if (settings->per_min == 0) {
    fprintf(stderr,
            "%s:%d: Minimum period invalid. Please specify a positive number "
            "(e.g. "
            "--period-min=10).\n",
            __FILE__, __LINE__);
    return 0;
  }
  if (settings->per_max == 0) {
    fprintf(stderr,
            "%s:%d: Maximum period invalid. Please specify a positive number "
            "(e.g. "
            "--period-max=30).\n",
            __FILE__, __LINE__);
    return 0;
  }
  if (settings->norm_dl_avg == 0) {
    fprintf(stderr,
            "%s:%d: Relative deadline average invalid. Please specify a "
            "positive number (e.g. "
            "--relative-dl-avg=1).\n",
            __FILE__, __LINE__);
    return 0;
  }
  if (settings->norm_dl_var == 0) {
    fprintf(stderr,
            "%s:%d: Relative deadline variance invalid. Please specify a "
            "positive number (e.g. "
            "--relative-dl-var=0.1).\n",
            __FILE__, __LINE__);
    return 0;
    /* The two following */
  }

  if (settings->eps == 0) {
    fprintf(stderr,
            "%s:%d: Tolerance for hyperperiod equals zero. There may be issues "
            "with floating "
            "point. You might want to add, for example \"--eps=1e-9\".\n",
            __FILE__, __LINE__);
  }

  if (settings->seed != 0 && settings->n_repeat > 1) {
    printf(
        "Warning: since option'--num-repeat' indicates the amount "
        "of task "
        "sets to be randomly generated and passed as input to the "
        "procedure,\n"
        "the value for seed is pre-determined as "
        "1 for the first task set's generation and increased by 1 for each "
        "subsequent task set.\n"
        "This is not a problem if you are  retrieving additional information "
        "about a particular task set. \nIf that is not the case, "
        "you might want to remove either '--num-repeat' or '--rand-seed'.\n");
  }
  return 1;
}

int verify_arg_int(char *arg) {
  int i = 0;

  while (arg[i] != '\000') {
    if (!isdigit(arg[i])) {
      return 0;
    }
    i++;
  }
  return 1;
}

/* Prints the value of every mandatory parameter needed for the randomization
 * of the task set. */
void print_rand_setup(ts_rand_t rand_setup) {
  printf("----------- Input arguments---------------------\n");
  if (rand_setup.n_repeat < 100000000)
    printf("-- n. repetitions:\t\t%d\t\t|\n", rand_setup.n_repeat);
  else
    printf("-- n. repetitions:\t\t%d\t|\n", rand_setup.n_repeat);

  printf("-- seed:\t\t\t%u\t\t|\n", rand_setup.seed);
  printf("-- num tasks:\t\t\t%d\t\t|\n", rand_setup.num);
  printf("-- per min:\t\t\t%f\t|\n", rand_setup.per_min);
  printf("-- per max:\t\t\t%f\t|\n", rand_setup.per_max);
  printf("-- phasing:\t\t\t%s\t\t|\n", rand_setup.phasing ? "yes" : "no");
  printf("-- relative dl avg:\t\t%f\t|\n", rand_setup.norm_dl_avg);
  printf("-- relative dl var:\t\t%f\t|\n", rand_setup.norm_dl_var);
  printf("-- eps:\t\t\t\t%lf\t|\n", rand_setup.eps);
  printf("-- constraints info on csv:\t%s\t\t|\n",
         arguments.add_constraints_info ? "yes" : "no");
  printf("------------------------------------------------\n");
}

void main_file_mode(char *input_filename) {
  ts_t my_task_set;
  edf_points_t my_points;
  struct timespec start, check;
  double time_points, time_qhull;

  /* Initialization */
  ts_set_zero(&my_task_set);
  edf_set_zero(&my_points);

  ts_read_alloc(&my_task_set, input_filename);

  printf("Input filename : %s\n", input_filename);
  ts_print(&my_task_set);

  clock_gettime(CLOCK_MONOTONIC, &start);
  edf_create_points(&my_task_set, &my_points);
  clock_gettime(CLOCK_MONOTONIC, &check);
  time_points =
      (check.tv_nsec - start.tv_nsec) * 1e-9 + (check.tv_sec - start.tv_sec);
  if (arguments.verbose) { /* verbose output*/
    edf_print_points(&my_points);
  }
  time_qhull = edf_qhull_points(&my_points);
  edf_print_constraints_C(&my_points);
  edf_print_constraints_U(&my_task_set, &my_points);
  edf_print_stats(&my_points, &my_task_set, time_points, time_qhull);
  if (arguments.add_constraints_info)
    edf_print_additional_info_on_csv(&my_points, &my_task_set, NO_SEED);
  edf_free_points(&my_points);
  ts_free(&my_task_set);
}

void main_rand_mode() {
  ts_rand_t rand_setup = arguments.rand_setup;
  ts_t my_task_set;
  edf_points_t my_points;
  int num_tasks;
  char *s = NULL;
  size_t dim = 0;
  int i = 0;
  struct timespec start, check;
  double time_points, time_qhull;

  /* Initialization */
  ts_set_zero(&my_task_set);
  edf_set_zero(&my_points);

  /* only method implemented for deadline generation */
  rand_setup.dl_m = dl_unif;

  /* only method implemented for period generation */
  rand_setup.per_m = per_unif;

  /* Generate the task set */
  ts_rand(&my_task_set, &rand_setup);

  clock_gettime(CLOCK_MONOTONIC, &start);
  edf_create_points(&my_task_set, &my_points);
  clock_gettime(CLOCK_MONOTONIC, &check);
  time_points =
      (check.tv_nsec - start.tv_nsec) * 1e-9 + (check.tv_sec - start.tv_sec);
  if (arguments.verbose) {
    /* verbose output*/
    edf_print_points(&my_points);
  }
  time_qhull = edf_qhull_points(&my_points);

  if (rand_setup.n_repeat == 1) {
    edf_print_constraints_C(&my_points);
    edf_print_constraints_U(&my_task_set, &my_points);
    edf_print_stats(&my_points, &my_task_set, time_points, time_qhull);
  } else {
    edf_print_stats_on_csv(&rand_setup, &my_points, &my_task_set);
  }
  edf_free_points(&my_points);
  ts_free(&my_task_set);
}

void main_constraints_info() {
  ts_rand_t rand_setup = arguments.rand_setup;
  ts_t my_task_set;
  edf_points_t my_points;
  int num_tasks;
  char *s = NULL;
  size_t dim = 0;
  int i = 0;

  /* Initialization */
  ts_set_zero(&my_task_set);
  edf_set_zero(&my_points);

  /* only method implemented for deadline generation */
  rand_setup.dl_m = dl_unif;

  /* only method implemented for period generation */
  rand_setup.per_m = per_unif;

  /* Generate the task set and print on terminal the result*/
  ts_rand(&my_task_set, &rand_setup);

  edf_create_points(&my_task_set, &my_points);
  if (arguments.verbose) { /* verbose output*/
    edf_print_points(&my_points);
  }
  edf_qhull_points(&my_points);
  edf_print_additional_info_on_csv(&my_points, &my_task_set, rand_setup.seed);

  /*Free memory*/
  edf_free_points(&my_points);
  ts_free(&my_task_set);
}

void edf_print_stats(edf_points_t *my_points, const ts_t *my_task_set,
                     double time_points, double time_qhull) {
  printf("\nNumber of total constraints:\t\t%d\n", my_points->num_points);
  printf("Number of minimal constraints:\t\t%d\n", my_points->num_sel);
  printf("Number of minimal constraints (w/o positivity constraints"
         "\n\t but including total utilization constraint Ui <= 1):  "
         "%d\n",
         my_points->num_sel - my_task_set->num);

  printf("Fraction of necessary constraints:\t%f\n",
         my_points->num_sel / (double)my_points->num_points);
  if (arguments.verbose && !arguments.add_constraints_info) {
    printf("Time points: %f secs\nTime qhull: %f secs\n", time_points,
           time_qhull);
  }
}

/**
 * For each constraint, prints on csv file the following information:
 * - seed
 * - number of minimal constraints (w/o positivity constraints)
 * - absolute deadline checked by constraint (t)
 * - hyperperiod
 * - command line that generated the task set
 *
 * - for each task:
 *        - period,
 *        - deadline,
 *        - ratio between the two (D_i/T_i),
 *        - difference between last absolute deadline generated from task and
 *          't' related to the constraint
 *        - a boolean value indicating whether the task generated the
 *            absolute deadline or not.
 */
void edf_print_additional_info_on_csv(edf_points_t *my_points,
                                      const ts_t *my_task_set, int seed) {

#define IND                                                                    \
  (my_points->vec_sel[i])      /*index (of the original constraints array)     \
                     containing a constraint included in the minimal set  */
#define T (my_points->t1[IND]) /* absolute deadline*/
#define D_j (my_task_set->dl[j])
#define P_j (my_task_set->per[j])
  int i, j;
  double diff;
  double abs_dl;
  int actual_m = my_points->num_sel - my_task_set->num;
  int *n_tasks_generating_dl = malloc(sizeof(int) * my_task_set->num);
  memset(n_tasks_generating_dl, 0, sizeof(n_tasks_generating_dl));

  char *filename = malloc(MAX_SIZE_STR_FILENAME);

  sprintf(filename, "../datasets/additional_info/n-%d_m-%d.csv",
          my_task_set->num, actual_m);

  FILE *fp = fopen(filename, "w");
  if (fp == NULL) {
    fprintf(stderr, "main: unable to open file for additional info\n");
    exit(EXIT_FAILURE);
  }

  printf("[edf_hull] Printing %d row(s) on file \'./%s\'\n",
         arguments.rand_setup.n_repeat, filename);

#ifdef EDFH_DEBUG
  /**
   * Excluding the first my_task_set->num constraints, which are the
   * positivity ones
   */
  for (i = my_task_set->num; i < my_points->num_sel; i++) {
    for (j = 0; j < my_points->num_tasks; j++) {
      printf("Per t = %f:\n", T);
      abs_dl =
          (D_j + (my_points->vec_p[IND * my_points->num_tasks + j] - 1) * P_j);
      diff = T - abs_dl;
      printf("\tdeadline assoluta del %d-task è %f, con diff=%f\n", j + 1,
             abs_dl, diff);
      printf("index %d : IND=%d * num_tasks=%d + j=%d\n",
             IND * my_points->num_tasks + j, IND, my_points->num_tasks, j);
      printf("vec_p[%d]-1 : %f\n", IND * my_points->num_tasks + j,
             my_points->vec_p[IND * my_points->num_tasks + j] - 1);
    }
  }
#endif

  /*Printing header of csv file*/
  fprintf(fp, "Seed,");
  for (int i = 1; i <= my_task_set->num; i++) {
    fprintf(fp, "T%d,D%d,Ratio%d,a_%i,", i, i, i, i);
  }
  fprintf(fp, "t,");
  for (int i = 1; i <= my_task_set->num; i++) {
    fprintf(fp, "diff%d,", i);
  }
  for (int i = 1; i <= my_task_set->num; i++) {
    fprintf(fp, "task%d_gen_t,", i);
  }
  fprintf(fp, "H,m,Command\n");

  /*Printing the seed that generated the task set*/
  for (i = my_task_set->num; i < my_points->num_sel; i++) {
    fprintf(fp, "%d,", seed);

    /*Printing T_i, D_i and Ratio D_i/T_i and a_i on csv*/
    for (int j = 0; j < my_task_set->num; j++) {
      fprintf(fp, "%.0f,%f,%f,%.17g,", my_task_set->per[j], my_task_set->dl[j],
              my_task_set->dl[j] / my_task_set->per[j],
              (my_points->vec_p[IND * my_points->num_tasks + j] * P_j) /
                  my_points->t1[IND]);
    }

    /*Printing instant t relative to constraint*/
    fprintf(fp, "%f,", T);

    /*Printing difference between absolute deadline of i-task and t1*/
    for (j = 0; j < my_points->num_tasks; j++) {
      abs_dl =
          (D_j + (my_points->vec_p[IND * my_points->num_tasks + j] - 1) * P_j);
      diff = T - abs_dl;
      if (diff == 0) {
        n_tasks_generating_dl[j] = 1;
      } else {
        n_tasks_generating_dl[j] = 0;
      }
      fprintf(fp, "%f,", diff);
    }

    /*Printing task that generated t1*/
    for (j = 0; j < my_task_set->num; j++) {
      fprintf(fp, "%d,", n_tasks_generating_dl[j]);
    }

    /*Printing hyperperiod of current task set on csv*/
    fprintf(fp, "%.0f,", my_task_set->h_per);

    /*Printing number of minimal constraints on csv*/
    fprintf(fp, "%d,", my_points->num_sel - my_task_set->num);

    /*Printing command line*/
    fprintf(fp, "%s\n", command);
  }

  fclose(fp);
  free(n_tasks_generating_dl);
  free(filename);
}

#undef T1
#undef D_j
#undef P_j
#undef IND

void edf_print_stats_on_csv(const ts_rand_t *settings, edf_points_t *my_points,
                            const ts_t *my_task_set) {
  double percentage_of_constraints =
      (double)(my_points->num_sel) / (double)(my_points->num_points);

  /*Printing the seed that generated the task set*/
  fprintf(settings->fp_stats_csv, "%d,", settings->seed);

  /*Printing T_i, D_i and Ratio D_i/T_i on csv*/
  for (int i = 0; i < settings->num; i++) {
    fprintf(settings->fp_stats_csv, "%.0f,%f,%f,", my_task_set->per[i],
            my_task_set->dl[i], my_task_set->dl[i] / my_task_set->per[i]);
  }

  /*Printing hyperperiod of current task set on csv*/
  fprintf(settings->fp_stats_csv, "%.0f,", my_task_set->h_per);

  /*Printing number of minimal constraints on csv*/
  fprintf(settings->fp_stats_csv, "%d,", my_points->num_sel - my_task_set->num);

  /*Printing number of constraints before procedure on csv*/
  fprintf(settings->fp_stats_csv, "%d,",
          my_points->num_points - my_task_set->num);

  /*Printing percentage of constraints reduction after procedure on csv*/
  fprintf(settings->fp_stats_csv, "%f,", percentage_of_constraints);

  /*Printing command line*/
  fprintf(settings->fp_stats_csv, "%s\n", command);
}

#if 0
int main_spanDL(int argc, char* argv[])
{
#define NUM_TASKS 6

	ts_t         my_task_set;
	ts_rand_t    rand_setup;
	edf_points_t my_points;
	double max_d, max_o;
	struct timespec start, check;
	double time_points, time_qhull;
	double dl_span[] = {0.5, 0.6, 0.7, 0.8, 0.9, 1, 1.1, 1.2, 1.3, 1.4, 1.5};
	double var_span[] = {0.4, 0.3, 0.2, 0.1, 0};
	int i, j, k, iter=0;
	double cur_dl, min_dl, max_dl;

	if (argc >= 2) {
		fdata = fopen(argv[1],"a");
	} else {
		fdata = fopen(FILENAME,"a");
	}

	my_task_set.num = 0;
	my_task_set.per = NULL;
	my_task_set.dl = NULL;
	my_task_set.phi = NULL;
	rand_setup.per_m = per_unif;
	rand_setup.per_min = 2;
	rand_setup.per_max = 20;
	rand_setup.norm_dl_avg = 0.5;
	rand_setup.norm_dl_var = 0.2;
	rand_setup.phasing = 0;
	my_points.alloc_points = 0;
	my_points.t0 = NULL;
	my_points.t1 = NULL;
	my_points.vec_p = NULL;
	my_points.qh_vec_p = NULL;
	my_points.num_sel = 0;
	my_points.vec_sel = NULL;
	srand(time(NULL));
	while (1) {
		for(i=0; i<LEN(dl_span); i++) {
			rand_setup.norm_dl_avg = dl_span[i];
			for(j=0; j<LEN(var_span); j++) {
				rand_setup.norm_dl_var = var_span[j];
				if (rand_setup.norm_dl_avg-rand_setup.norm_dl_var >= 1-1e-8) {
					/* All tasks with deadline >= period */
					continue;
				}
				if (rand_setup.norm_dl_avg+rand_setup.norm_dl_var <= 1.1) {
					/* Constrained deadline
					   tasks. They seem to be
					   easier: SKIPPING */
					continue;
				}
				while(1) {
					rand_setup.seed = rand();
					ts_rand(&my_task_set, &rand_setup, NUM_TASKS);
					/*  min/max deadline/period */
					max_dl = min_dl =
						my_task_set.dl[0]/ my_task_set.per[0];
					for (k=1; k<my_task_set.num; k++) {
						cur_dl = my_task_set.dl[k]/my_task_set.per[k];
						if (cur_dl < min_dl)
							min_dl = cur_dl;
						if (cur_dl > max_dl)
							max_dl = cur_dl;
					}
					if (max_dl < 0.9 || min_dl >=1)
						/* Hardest seems to be
						 * a mixture of arb
						 * and constrained
						 * DL */
						continue;
					if (fabs(my_task_set.h_per_tol) <= 1e-20)
						/* Keep only if hyperP exact */
						break;
				}
				fprintf(fdata, "%u,%u,%f,%f,%u,%f,%f,%f,",
					rand_setup.seed, rand_setup.num_tasks,
					rand_setup.per_min, rand_setup.per_max, rand_setup.phasing,
					rand_setup.norm_dl_avg, rand_setup.norm_dl_var,
					my_task_set.h_per);
				fflush(fdata);
				clock_gettime(CLOCK_MONOTONIC, &start);
				edf_create_points(&my_task_set, &my_points);
				clock_gettime(CLOCK_MONOTONIC, &check);
				time_points = (check.tv_nsec-start.tv_nsec)*1e-9
					+(check.tv_sec-start.tv_sec);
				edf_qhull_points(&my_points);
				clock_gettime(CLOCK_MONOTONIC, &check);
				time_qhull = (check.tv_nsec-start.tv_nsec)*1e-9
					+(check.tv_sec-start.tv_sec)-time_points;
				fprintf(fdata, "%u,%u,%f,%f\n",
					my_points.num_points, my_points.num_sel,
					time_points, time_qhull);
			}
		}
		printf("%d\t", ++iter);
	}
}
#endif

#if 0
int main_span_per(int argc, char* argv[])
/*int main(int argc, char* argv[])*/
{
	ts_t         my_task_set;
	ts_rand_t    rand_setup;
	edf_points_t my_points;
	double max_d, max_o;
	struct timespec start, check;
	double time_points, time_qhull;
	int num_span[] = {4};
	int i, j, k, iter=0;
	double cur_dl, min_dl, max_dl;

	if (argc >= 2) {
		fdata = fopen(argv[1],"a");
	} else {
		fdata = fopen(FILENAME,"a");
	}

	/* Initialization */
	my_task_set.num = 0;
	my_task_set.per = NULL;
	my_task_set.dl = NULL;
	my_task_set.phi = NULL;
	rand_setup.per_m = per_unif;
	rand_setup.num_tasks = 4;  /* to be changed in this experiment */
	rand_setup.per_min = 2;
	rand_setup.per_max = 200;
	rand_setup.norm_dl_avg = 1;
	rand_setup.norm_dl_var = 0.4;
	rand_setup.phasing = 0;
	my_points.alloc_points = 0;
	my_points.t0 = NULL;
	my_points.t1 = NULL;
	my_points.vec_p = NULL;
	my_points.qh_vec_p = NULL;
	my_points.num_sel = 0;
	my_points.vec_sel = NULL;
	srand(time(NULL));
	while (1) {
		for(i=0; i<LEN(num_span); i++) {
			rand_setup.num_tasks = num_span[i];
			while(1) {
				rand_setup.seed = rand();
				ts_rand(&my_task_set, &rand_setup);
				/*  min/max deadline/period */
				max_dl = min_dl =
					my_task_set.dl[0]/ my_task_set.per[0];
				for (k=1; k<my_task_set.num; k++) {
					cur_dl = my_task_set.dl[k]/my_task_set.per[k];
					if (cur_dl < min_dl)
						min_dl = cur_dl;
					if (cur_dl > max_dl)
						max_dl = cur_dl;
				}
				if (max_dl < 0.9 || min_dl >=1)
					/* Hardest seems to be a
					 * mixture of arb and
					 * constrained DL */
					continue;
				if (fabs(my_task_set.h_per_tol) <= 1e-20)
					/* Keep only if hyperP exact */
					break;
			}
			fprintf(fdata, "%u,%u,%f,%f,%u,%f,%f,%f,",
				rand_setup.seed, rand_setup.num_tasks,
				rand_setup.per_min, rand_setup.per_max, rand_setup.phasing,
				rand_setup.norm_dl_avg, rand_setup.norm_dl_var,
				my_task_set.h_per);
			fflush(fdata);
			clock_gettime(CLOCK_MONOTONIC, &start);
			edf_create_points(&my_task_set, &my_points);
			clock_gettime(CLOCK_MONOTONIC, &check);
			time_points = (check.tv_nsec-start.tv_nsec)*1e-9
				+(check.tv_sec-start.tv_sec);
			edf_qhull_points(&my_points);
			clock_gettime(CLOCK_MONOTONIC, &check);
			time_qhull = (check.tv_nsec-start.tv_nsec)*1e-9
				+(check.tv_sec-start.tv_sec)-time_points;
			fprintf(fdata, "%u,%u,%f,%f\n",
				my_points.num_points, my_points.num_sel,
				time_points, time_qhull);
		}
		/*printf("%d\t", ++iter); */
	}
}
#endif

#if 0
int main_num(int argc, char* argv[])
/*int main(int argc, char* argv[])*/
{
	ts_t         my_task_set;
	ts_rand_t    rand_setup;
	edf_points_t my_points;
	double max_d, max_o;
	struct timespec start, check;
	double time_points, time_qhull;
	int num_span[] = {8, 7, 6, 5, 4, 3, 2};
	int i, j, k, iter=0;
	double cur_dl, min_dl, max_dl;

	if (argc >= 2) {
		fdata = fopen(argv[1],"a");
	} else {
		fdata = fopen(FILENAME,"a");
	}

	/* Initialization */
	my_task_set.num = 0;
	my_task_set.per = NULL;
	my_task_set.dl = NULL;
	my_task_set.phi = NULL;
	rand_setup.per_m = per_unif;
	rand_setup.num_tasks = 3;  /* to be changed in this experiment */
	rand_setup.per_min = 2;
	rand_setup.per_max = 1000;  /* to be changed in this experiment */
	rand_setup.norm_dl_avg = 1;
	rand_setup.norm_dl_var = 0.4;
	rand_setup.phasing = 0;
	my_points.alloc_points = 0;
	my_points.t0 = NULL;
	my_points.t1 = NULL;
	my_points.vec_p = NULL;
	my_points.qh_vec_p = NULL;
	my_points.num_sel = 0;
	my_points.vec_sel = NULL;
	srand(time(NULL));
	while (1) {
		for(i=0; i<LEN(num_span); i++) {
			rand_setup.num_tasks = num_span[i];
			rand_setup.per_max = ceil(pow(1e6,1.0/(double)num_span[i]))+10;
			while(1) {
				rand_setup.seed = rand();
				ts_rand(&my_task_set, &rand_setup);
				/*  min/max deadline/period */
				max_dl = min_dl =
					my_task_set.dl[0]/ my_task_set.per[0];
				for (k=1; k<my_task_set.num; k++) {
					cur_dl = my_task_set.dl[k]/my_task_set.per[k];
					if (cur_dl < min_dl)
						min_dl = cur_dl;
					if (cur_dl > max_dl)
						max_dl = cur_dl;
				}
				if (max_dl < 0.9 || min_dl >=1)
					/* Hardest seems to be a
					 * mixture of arb and
					 * constrained DL */
					continue;
				if (fabs(my_task_set.h_per_tol) <= 1e-20)
					/* Keep only if hyperP exact */
					break;
			}
			fprintf(fdata, "%u,%u,%f,%f,%u,%f,%f,%f,",
				rand_setup.seed, rand_setup.num_tasks,
				rand_setup.per_min, rand_setup.per_max, rand_setup.phasing,
				rand_setup.norm_dl_avg, rand_setup.norm_dl_var,
				my_task_set.h_per);
			fflush(fdata);
			clock_gettime(CLOCK_MONOTONIC, &start);
			edf_create_points(&my_task_set, &my_points);
			clock_gettime(CLOCK_MONOTONIC, &check);
			time_points = (check.tv_nsec-start.tv_nsec)*1e-9
				+(check.tv_sec-start.tv_sec);
			edf_qhull_points(&my_points);
			clock_gettime(CLOCK_MONOTONIC, &check);
			time_qhull = (check.tv_nsec-start.tv_nsec)*1e-9
				+(check.tv_sec-start.tv_sec)-time_points;
			fprintf(fdata, "%u,%u,%f,%f\n",
				my_points.num_points, my_points.num_sel,
				time_points, time_qhull);
		}
		/*printf("%d\t", ++iter); */
	}
}
#endif
